---
title: "R Notebook"
output: html_notebook
---

Load libraries:
```{r message=FALSE}
library(data.table)
library(dplyr)
library(gdistance)
library(kableExtra)
library(raster)
library(rgdal)
library(sf)
library(tidyverse)
library(units)
```

# Load data

Load geography:
```{r}
load("population_sobi.RData") #interpolated population in SoBi area
load("sobi_hubs.RData") #location of SoBi hubs, minus Van Wagner's beach
load("sobi_service.RData") #core service area for SoBi
load("ttm_walk.RData") #travel time matrix for interpolated population in SoBi area
```

```{r}
summary(ttm_walk) #time is in minutes
```
# Threshold

Calculate quantiles according to distance. This is done to select a threshold:
```{r}
quantiles_d <- quantile(as.vector(ttm_walk$travel_time), probs = c(0, 1/10, 3/10, 5/10, 7/10, 8/10, 9/10))

dist_threshold <- quantile(as.vector(ttm_walk$travel_time), probs = c(0, 1/10, 3/10, 5/10, 7/10, 8/10, 9/10))[[5]]
```

The distance threshold is equivalent to the _kernel bandwidth_ or _catchment distance_.

# Set up matrix

Add population information:
```{r}
ttm_walk <- left_join(ttm_walk, 
                      population_sobi,
                      by = "UID")
```

Drop the geometry:
```{r}
ttm_walk <- ttm_walk %>% dplyr::select(-geometry)
```

Add number of bicycle racks per SoBi hub as a measure of the level of supply:
```{r}
ttm_walk <- left_join(ttm_walk, sobi_hubs %>% dplyr::select(OBJECTID, RACKS_AMOU), by=c("OBJECTID" = "OBJECTID"))
ttm_walk <- ttm_walk %>% dplyr::select(-geometry)
head(ttm_walk)
```

Rename columns:
```{r}
names(ttm_walk) <- c('UID', 'hub', 'travel_time', 'population', 'racks')
```

[**Note for Dr. Paez: do we want the binary and Gaussian functions? Or only one of them?**]

Calculate impedance (binary):
```{r eval=TRUE}
# Run only if binary function desired
# Change chunk option eval=TRUE to FALSE if impedance is Gaussian function
ttm_walk <- ttm_walk %>%
  mutate(impedance_binary = ifelse(travel_time <= dist_threshold, 1, 0))
```

Calculate impedance (Gaussian):
```{r eval=FALSE}
# Run only if Gaussian function desired
# Change chunk option eval=FALSE to TRUE if impedance is Gaussian function
ttm_walk <- ttm_walk %>%
  mutate(impedance_gaussian = case_when(travel_time <= quantiles_d[1] ~ 0.945,
                               (travel_time > quantiles_d[1]) & (travel_time <= quantiles_d[3]) ~ 0.600,
                               (travel_time > quantiles_d[3]) & (travel_time <= quantiles_d[5]) ~ 0.242,
                               travel_time > quantiles_d[5] ~ 0))
```


Calculate the sum of the impedance by population for the balancing factors. In the binary case, this should be the same as the number of SoBi hubs that each interpolated population unit can reach; when the impedance is not binary, this is the sum of all impedance values:
```{r}
sum_b1 <- ttm_walk %>%
  group_by(UID) %>%
  summarize(sum_b1 = sum(impedance_binary),
            .groups = "drop")
sum_b1
```

The interpolated population at unit 15 can reach eight SoBi hubs, the population at unit 16 can reach six SoBi hubs, the population at unit 30 can reach zero hubs clinics, etc. [**Note for Dr. Paez: why do the unit IDs start at 15 and not 1?**

Calculate the sum of the impedance by SoBi hubs for the balancing factors. In the binary case, this should be the same as the number of interpolated population unit that each SoBi hub serves; when the impedance is not binary, this is the sum of all impedance values:
```{r}
sum_b2 <- ttm_walk %>%
  group_by(hub) %>%
  summarize(sum_b2 = sum(impedance_binary))
sum_b2
```

Hub 1 serves 1502 interpolated population units, hub 2 serves 1393 population units, etc.

Next, join the sum of the impedance to the table to calculate the balanced impedance values:
```{r}
ttm_walk <- ttm_walk %>%
  left_join(sum_b1, by = "UID") %>%
  left_join(sum_b2, by = "hub")
```

Calculate balanced impedance values:
```{r}
ttm_walk <- ttm_walk %>%
  mutate(balanced_impedance_1 = impedance_binary/sum_b1,
         balanced_impedance_2 = impedance_binary/sum_b2)
```

# Calculate level of service

Check the balanced_impedance factors for the population units:
```{r}
ttm_walk %>% 
   dplyr::filter(hub == "46") 
```

[**Note: not sure if this step is needed for SoBi?**] *Notice that the population of each center is sorted among the three clinics proportionally. Thanks to this property, the sum of the population serviced equals the total population in the system:*
```{r}
ttm_walk %>%
  group_by(UID) %>%
  summarize(pop_served = sum(sum(population * balanced_impedance_1)),
            .groups = "drop") %>%
  pull(pop_served) %>%
  sum()

population_sobi %>% 
  pull(population) %>% 
  sum()
```

The level of service of each hub is the number of bicycle racks at the hub, divided by the population that they serve:
```{r}
sobi_los <- ttm_walk %>%
  dplyr::filter(impedance_binary > 0) %>% # filter impedance == 0 to avoid divisions by zero
  group_by(hub) %>%
  summarize(sobi_los = first(racks) / sum((population * balanced_impedance_1)),
            .groups = "drop")
sobi_los
```

Join the level of service to the table:
```{r}
ttm_walk <- ttm_walk %>%
  left_join(sobi_los, by = "hub")
```

# Calculate accessibility

To calculate accessibility, the level of service of each hub needs to be distributed proportionally to the population units. 
```{r}
sobi_accessibility <- ttm_walk %>%
  group_by(UID) %>%
  summarize(accessibility = sum(sobi_los * balanced_impedance_2),
            .groups = "drop")
sobi_accessibility
```

Check that the sum of the accessibility is equal to the available level of service:
```{r}
sobi_accessibility %>% 
  pull(accessibility) %>% 
  sum()

sobi_los %>% 
  pull(sobi_los) %>%
  sum()
```
[**END FOR SOBI ACCESSIBILITY**]

# Complete  (or tl;dr version)

The full algorithm can be written in this way. 

Obtain the matrix in long form (this is line 85 in this file):
```{r}
long_matrix <- left_join(distance_matrix_long, Clinics_data, by=c("to" = "id"))
```

Calculate the accessibility and level of service:
```{r}
# Calculate impedance (binary)
# long_matrix <- long_matrix %>%
#   mutate(distance = drop_units(distance),
#          impedance = ifelse(distance <= dist_threshold, 1, 0))

# Calculate impedance (Gaussian)
long_matrix <- long_matrix %>%
  mutate(distance = drop_units(distance),
         impedance = case_when(distance <= quantiles_d[1] ~ 0.945,
                               (distance > quantiles_d[1]) & (distance <= quantiles_d[3]) ~ 0.600,
                               (distance > quantiles_d[3]) & (distance <= quantiles_d[5]) ~ 0.242,
                               distance > quantiles_d[5] ~ 0))

# Calculate first set of balancing factors
sum_b1 <- long_matrix %>%
  group_by(id) %>%
  summarize(sum_b1 = sum(impedance),
            .groups = "drop")

# Calculate second set of balancing factors
sum_b2 <- long_matrix %>%
  group_by(to) %>%
  summarize(sum_b2 = sum(impedance),
            .groups = "drop")

# Join the sum of the impedance to the table to calculate the balanced impedance values:
long_matrix <- long_matrix %>%
  left_join(sum_b1, by = "id") %>%
  left_join(sum_b2, by = "to")

# Calculate the balanced impedance
long_matrix <- long_matrix %>%
  mutate(balanced_impedance_1 = impedance/sum_b1,
         balanced_impedance_2 = impedance/sum_b2)

# Calculate the level of service
los <- long_matrix %>%
  filter(impedance > 0) %>% # filter impedance == 0 to avoid divisions by zero
  group_by(to) %>%
  summarize(los = first(Doctors) / sum((Population * balanced_impedance_1)),
            .groups = "drop")

# Join the level of service to the table:
long_matrix <- long_matrix %>%
  left_join(los, by = "to")

# Calculate accessibility
accessibility <- long_matrix %>%
  group_by(id) %>%
  summarize(accessibility = sum(los * balanced_impedance_2),
            .groups = "drop")
```

This is the accessibility:
```{r}
accessibility
```

This is the level of service:
```{r}
los
```


