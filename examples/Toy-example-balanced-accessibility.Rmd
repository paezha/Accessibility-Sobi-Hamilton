---
title: "R Notebook"
output: html_notebook
---

Load libraries:
```{r message=FALSE}
library(data.table)
library(dplyr)
library(gdistance)
library(kableExtra)
library(raster)
library(rgdal)
library(sf)
library(tidyverse)
library(units)
```

# Load data

Load geography:
```{r}
load("population_sobi.RData") #interpolated population in SoBi area
load("sobi_hubs.RData") #location of SoBi hubs, minus Van Wagner's beach
load("sobi_service.RData") #core service area for SoBi
load("ttm_walk.RData") #travel time matrix for interpolated population in SoBi area
```

```{r}
summary(ttm_walk) #time is in minutes
```

# Check the data

Plot the interpolated population:
```{r}
ggplot(data = population_sobi) +
  geom_sf(aes(color = population)) +
  geom_sf(data = sobi_service,
          fill = NA) +
  scale_color_distiller(palette = "YlOrRd", 
                        direction = 1)
```

Notice that the population units begin with UID 1 and ends with UID 11388:
```{r}
summary(population_sobi)
```

The travel time table, on the other hand, begins with population UID 15 and ends with UID 11305:
```{r}
summary(ttm_walk)
```

What explains this discrepancy? We can compare the population units that are in the population dataset but not in the travel time table:
```{r}
ggplot() +
  geom_sf(data = sobi_service) +
  geom_sf(data = population_sobi %>%
            filter(!(UID %in% (distinct(ttm_walk, # filter observations with UIDs that are present in the travel time table
                                        UID) %>% 
                                 pull(UID)))))

```

The reason that some population units do not appear in the travel time table is that they are outside of the service area of SoBi and/or cannot reach SoBi hubs by walking.

# Threshold

Calculate quantiles according to distance. This is done to select a threshold:
```{r}
quantiles_d <- quantile(as.vector(ttm_walk$travel_time), probs = c(0, 1/10, 3/10, 5/10, 7/10, 8/10, 9/10))

dist_threshold <- quantile(as.vector(ttm_walk$travel_time), probs = c(0, 1/10, 3/10, 5/10, 7/10, 8/10, 9/10))[[5]]
```

The distance threshold is equivalent to the _kernel bandwidth_ or _catchment distance_.

# Set up matrix

Add population information:
```{r}
ttm_walk <- left_join(ttm_walk, 
                      population_sobi,
                      by = "UID")
```

Drop the geometry:
```{r}
ttm_walk <- ttm_walk %>% dplyr::select(-geometry)
```

Add number of bicycle racks per SoBi hub as a measure of the level of supply:
```{r}
ttm_walk <- left_join(ttm_walk, sobi_hubs %>% dplyr::select(OBJECTID, RACKS_AMOU), by=c("OBJECTID" = "OBJECTID"))
ttm_walk <- ttm_walk %>% dplyr::select(-geometry)
head(ttm_walk)
```

Rename columns:
```{r}
names(ttm_walk) <- c('UID', 'hub', 'travel_time', 'population', 'racks')
```

Calculate impedance (binary):
```{r eval=TRUE}
# Run only if binary function desired
# Change chunk option eval=TRUE to FALSE if impedance is Gaussian function
ttm_walk <- ttm_walk %>%
  mutate(impedance_binary = ifelse(travel_time <= dist_threshold, 1, 0))
```

Check the value of the dist_threshold:
```{r}
dist_threshold
```

Our calculations assume that people do not go further than 24 min to reach a SoBi hub.

Calculate impedance (Gaussian):
```{r eval=FALSE}
# Run only if Gaussian function desired
# Change chunk option eval=FALSE to TRUE if impedance is Gaussian function
ttm_walk <- ttm_walk %>%
  mutate(impedance_gaussian = case_when(travel_time <= quantiles_d[1] ~ 0.945,
                                        (travel_time > quantiles_d[1]) & (travel_time <= quantiles_d[3]) ~ 0.600,
                                        (travel_time > quantiles_d[3]) & (travel_time <= quantiles_d[5]) ~ 0.242,
                                        travel_time > quantiles_d[5] ~ 0))
```


Calculate the sum of the impedance by population for the balancing factors. In the binary case, this should be the same as the number of SoBi hubs that each interpolated population unit can reach; when the impedance is not binary, this is the sum of all impedance values:
```{r}
sum_b1 <- ttm_walk %>%
  group_by(UID) %>%
  summarize(sum_b1 = sum(impedance_binary),
            .groups = "drop")
sum_b1
```

The interpolated population at unit 15 can reach eight SoBi hubs, the population at unit 16 can reach six SoBi hubs, the population at unit 30 can reach zero hubs clinics, etc..

Sanity check: how many stations are within 24 minutes or less from population UID 15?
```{r}
ttm_walk %>%
  filter(UID == 15, travel_time <= 24) %>%
  nrow()
```

**Important:** notice that some values of `sum_b1` are zeros! This means that some population units cannot reach a SoBi hub in at most 24 min. Since the balancing impedance is calculated by diving the impedance by `sum_b1`, this will lead to NaNs (divisions by zero). To avoid issues we will remove any population units that reach zero hubs:
```{r}
ttm_walk <- ttm_walk %>%
  dplyr::filter(sum_b1 > 0)
```

Calculate the sum of the impedance by SoBi hubs for the balancing factors. In the binary case, this should be the same as the number of interpolated population unit that each SoBi hub serves; when the impedance is not binary, this is the sum of all impedance values:
```{r}
sum_b2 <- ttm_walk %>%
  group_by(hub) %>%
  summarize(sum_b2 = sum(impedance_binary))
sum_b2
```

Hub 1 serves 1502 interpolated population units, hub 2 serves 1393 population units, etc.

Sanity check: how many population units are served by hub 1?
```{r}
ttm_walk %>%
  filter(hub == 1, travel_time <= 24) %>%
  nrow()
```

The values check. Next, are there any hubs that serve zero population units? (same issue with division by zero):
```{r}
ttm_walk$sum_b2 %>% 
  summary()
```

No zeros or other strange values, we're good.

Next, join the sum of the impedance to the table to calculate the balanced impedance values:
```{r}
ttm_walk <- ttm_walk %>%
  left_join(sum_b1, by = "UID") %>%
  left_join(sum_b2, by = "hub")
```

Calculate balanced impedance values:
```{r}
ttm_walk <- ttm_walk %>%
  mutate(balanced_impedance_1 = impedance_binary/sum_b1,
         balanced_impedance_2 = impedance_binary/sum_b2)
```

# Calculate level of service

Check the balanced_impedance factors for the population units:
```{r}
ttm_walk %>% 
  dplyr::filter(hub == "46") 
```

[**Note: not sure if this step is needed for SoBi?** **Note for Elise: this is only an intermediate check in the analysis, it is not strictly necessary**] *Notice that the population of each center is sorted among the SoBi hubs proportionally. Thanks to this property, the sum of the population serviced equals the total population in the system:*
```{r}
ttm_walk %>%
  group_by(UID) %>%
  summarize(pop_served = sum(sum(population * balanced_impedance_1)),
            .groups = "drop") %>%
  pull(pop_served) %>%
  sum()

population_sobi %>% 
  filter(UID %in% (distinct(ttm_walk,
                             UID) %>%
             pull(UID))) %>%
  pull(population) %>% 
  sum()
```

The level of service of each hub is the number of bicycle racks at the hub, divided by the population that they serve:
```{r}
sobi_los <- ttm_walk %>%
  dplyr::filter(impedance_binary > 0) %>% # filter impedance == 0 to avoid divisions by zero
  group_by(hub) %>%
  summarize(sobi_los = first(racks) / sum((population * balanced_impedance_1)),
            .groups = "drop")
sobi_los
```

Hub 1 has 0.01538 bicycles per person, hub 2 has 0.02446 bicycles per person, etc.

Join the level of service to the table:
```{r}
ttm_walk <- ttm_walk %>%
  left_join(sobi_los, by = "hub")
```

# Calculate accessibility

To calculate accessibility, the level of service of each hub needs to be distributed proportionally to the population units. 
```{r}
sobi_accessibility <- ttm_walk %>%
  group_by(UID) %>%
  summarize(accessibility = sum(sobi_los * balanced_impedance_2),
            .groups = "drop")
sobi_accessibility
```

Check that the sum of the accessibility is equal to the available level of service:
```{r}
sobi_accessibility %>% 
  pull(accessibility) %>% 
  sum()

sobi_los %>% 
  pull(sobi_los) %>%
  sum()
```

```{r}
ggplot(data = population_sobi) +
  geom_sf(aes(color = population))
```

Join the accessibility to the population units:
```{r}
population_sobi <- population_sobi %>%
  left_join(sobi_accessibility,
            by = "UID")
```

Plot accessibility:
```{r}
ggplot(data = population_sobi) +
  geom_sf(aes(color = accessibility)) +
  geom_sf(data = sobi_service,
          fill = NA) +
  scale_color_distiller(palette = "YlOrRd", 
                        direction = 1)
```

[**END FOR SOBI ACCESSIBILITY**]

<!--
# Complete  (or tl;dr version)

The full algorithm can be written in this way. 

Obtain the matrix in long form (this is line 85 in this file):
```{r}
long_matrix <- left_join(distance_matrix_long, Clinics_data, by=c("to" = "id"))
```

Calculate the accessibility and level of service:
```{r}
# Calculate impedance (binary)
# long_matrix <- long_matrix %>%
#   mutate(distance = drop_units(distance),
#          impedance = ifelse(distance <= dist_threshold, 1, 0))

# Calculate impedance (Gaussian)
long_matrix <- long_matrix %>%
  mutate(distance = drop_units(distance),
         impedance = case_when(distance <= quantiles_d[1] ~ 0.945,
                               (distance > quantiles_d[1]) & (distance <= quantiles_d[3]) ~ 0.600,
                               (distance > quantiles_d[3]) & (distance <= quantiles_d[5]) ~ 0.242,
                               distance > quantiles_d[5] ~ 0))

# Calculate first set of balancing factors
sum_b1 <- long_matrix %>%
  group_by(id) %>%
  summarize(sum_b1 = sum(impedance),
            .groups = "drop")

# Calculate second set of balancing factors
sum_b2 <- long_matrix %>%
  group_by(to) %>%
  summarize(sum_b2 = sum(impedance),
            .groups = "drop")

# Join the sum of the impedance to the table to calculate the balanced impedance values:
long_matrix <- long_matrix %>%
  left_join(sum_b1, by = "id") %>%
  left_join(sum_b2, by = "to")

# Calculate the balanced impedance
long_matrix <- long_matrix %>%
  mutate(balanced_impedance_1 = impedance/sum_b1,
         balanced_impedance_2 = impedance/sum_b2)

# Calculate the level of service
los <- long_matrix %>%
  filter(impedance > 0) %>% # filter impedance == 0 to avoid divisions by zero
  group_by(to) %>%
  summarize(los = first(Doctors) / sum((Population * balanced_impedance_1)),
            .groups = "drop")

# Join the level of service to the table:
long_matrix <- long_matrix %>%
  left_join(los, by = "to")

# Calculate accessibility
accessibility <- long_matrix %>%
  group_by(id) %>%
  summarize(accessibility = sum(los * balanced_impedance_2),
            .groups = "drop")
```

This is the accessibility:
```{r}
accessibility
```

This is the level of service:
```{r}
los
```

-->
